<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Typical Consumer App Architecture</title>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <style>
    :root {
      --bg: #1a1a2e;
      --surface: #16213e;
      --primary: #0f3460;
      --accent: #e94560;
      --accent2: #00d9ff;
      --text: #eaeaea;
      --text-muted: #a0a0a0;
      --code-bg: #0d1117;
      --success: #00c853;
      --warning: #ffc107;
    }

    * { box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      margin: 0;
      padding: 2rem;
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
    }

    h1 {
      color: var(--accent);
      border-bottom: 2px solid var(--accent);
      padding-bottom: 0.5rem;
    }

    h2 {
      color: var(--accent);
      margin-top: 3rem;
    }

    h3 {
      color: var(--accent2);
      margin-top: 2rem;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 1.1rem;
      margin-top: -0.5rem;
    }

    .mermaid {
      background: var(--surface);
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1.5rem 0;
    }

    pre {
      background: var(--code-bg);
      border-radius: 8px;
      padding: 1rem 1.5rem;
      overflow-x: auto;
      border-left: 3px solid var(--accent);
    }

    code {
      font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
      font-size: 0.9rem;
    }

    .inline-code {
      background: var(--code-bg);
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.85rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      background: var(--surface);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid var(--primary);
    }

    th {
      background: var(--primary);
      color: var(--accent);
      font-weight: 600;
    }

    tr:last-child td {
      border-bottom: none;
    }

    .card {
      background: var(--surface);
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1.5rem 0;
    }

    .highlight {
      color: var(--accent);
      font-weight: 600;
    }

    .highlight2 {
      color: var(--accent2);
      font-weight: 600;
    }

    .two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin: 1.5rem 0;
    }

    .lib-card {
      background: var(--surface);
      border-radius: 8px;
      padding: 1.5rem;
      border-top: 3px solid var(--accent);
    }

    .lib-card.get {
      border-top-color: var(--accent2);
    }

    .lib-card h4 {
      margin: 0 0 0.5rem 0;
      font-size: 1.2rem;
    }

    .lib-card.get h4 {
      color: var(--accent2);
    }

    .lib-card.put h4 {
      color: var(--accent);
    }

    .lib-card p {
      margin: 0;
      color: var(--text-muted);
    }

    .use-case {
      background: var(--surface);
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
      border-left: 3px solid var(--accent2);
    }

    .use-case h4 {
      color: var(--accent2);
      margin: 0 0 0.5rem 0;
    }

    .badge {
      display: inline-block;
      padding: 0.2rem 0.6rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-right: 0.5rem;
    }

    .badge.get {
      background: var(--accent2);
      color: var(--bg);
    }

    .badge.put {
      background: var(--accent);
      color: var(--bg);
    }

    .badge.both {
      background: linear-gradient(90deg, var(--accent2), var(--accent));
      color: var(--bg);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Typical Consumer App Architecture</h1>
    <p class="subtitle">Building applications with inflow-get + inflow-put</p>

    <h2>The Library Pair</h2>
    <p>Two libraries, one purpose: <strong>work with Inflow data locally</strong>.</p>

    <div class="two-col">
      <div class="lib-card get">
        <h4>inflow-get</h4>
        <p><strong>Seed</strong> your local SQLite from the Inflow API.<br/>
        Query with Drizzle ORM. No rate limits. Instant responses.</p>
      </div>
      <div class="lib-card put">
        <h4>inflow-put</h4>
        <p><strong>Write back</strong> local changes to the Inflow API.<br/>
        Validated payloads. Constraint-aware. Type-safe.</p>
      </div>
    </div>

    <div class="mermaid">
flowchart LR
    subgraph libs["Library Pair"]
        GET["inflow-get<br/><small>seed + query</small>"]
        PUT["inflow-put<br/><small>write back</small>"]
    end

    subgraph internal["Internal (you don't use directly)"]
        TYPES["inflow-api-types<br/><small>Zod schemas</small>"]
    end

    TYPES -.->|"informs"| GET
    TYPES -.->|"informs"| PUT

    API[("Inflow<br/>Cloud API")]

    API -->|"GET"| GET
    PUT -->|"PUT"| API

    style libs fill:#16213e,stroke:#e94560,stroke-width:2px
    style internal fill:#0f3460,stroke:#a0a0a0,stroke-dasharray: 5 5
    style GET fill:#0f3460,stroke:#00d9ff
    style PUT fill:#0f3460,stroke:#e94560
    style TYPES fill:#1a1a2e,stroke:#a0a0a0
    </div>

    <h2>Consumer App Architecture</h2>

    <div class="mermaid">
flowchart TB
    subgraph app["Your Application"]
        UI["UI / CLI / API"]
        BL["Business Logic"]

        subgraph data["Data Layer"]
            Q["Queries<br/><small>Drizzle ORM</small>"]
            W["Writes<br/><small>inflow-put</small>"]
        end
    end

    subgraph libs["Libraries"]
        GET["inflow-get"]
        PUT["inflow-put"]
    end

    DB[(SQLite<br/>inflow.db)]
    API[("Inflow API")]

    UI --> BL
    BL --> Q
    BL --> W

    Q --> DB
    GET -->|"seeds"| DB

    W --> PUT
    PUT --> API
    API -.->|"sync back"| GET

    style app fill:#16213e,stroke:#e94560,stroke-width:2px
    style data fill:#0f3460,stroke:#00d9ff
    style libs fill:#16213e,stroke:#a0a0a0
    style DB fill:#0f3460,stroke:#00d9ff
    style API fill:#1a1a2e,stroke:#e94560,stroke-width:2px
    </div>

    <h2>Lifecycle: Seed Once, Query Forever, Write When Needed</h2>

    <div class="mermaid">
sequenceDiagram
    participant Dev as Developer
    participant App as Your App
    participant DB as SQLite
    participant Get as inflow-get
    participant Put as inflow-put
    participant API as Inflow API

    rect rgb(15, 52, 96)
        Note over Dev,API: Setup (One Time)
        Dev->>Get: npm run seed
        Get->>API: GET all entities
        API-->>Get: JSON data
        Get->>DB: Store in SQLite
        Get-->>Dev: Ready!
    end

    rect rgb(22, 33, 62)
        Note over Dev,API: Daily Usage
        App->>DB: Query products, orders, etc.
        DB-->>App: Instant results
        App->>App: Business logic
        App->>Put: putProduct(changes)
        Put->>Put: Validate payload
        Put->>API: PUT /products
        API-->>Put: Success
        Put-->>App: Done
    end

    rect rgb(15, 52, 96)
        Note over Dev,API: Periodic Re-sync (Optional)
        Dev->>Get: npm run seed
        Get->>API: GET latest data
        Get->>DB: Update SQLite
    end
    </div>

    <h2>What Your package.json Looks Like</h2>

    <pre><code>{
  "name": "my-inflow-app",
  "dependencies": {
    "inflow-get": "github:ldraney/inflow-get",
    "inflow-put": "github:ldraney/inflow-put",
    "drizzle-orm": "^0.30.0"
  }
}</code></pre>

    <h2>Common Use Cases</h2>

    <div class="use-case">
      <h4><span class="badge get">GET</span> Reporting Dashboard</h4>
      <p>Query SQLite for instant aggregations. No API rate limits.</p>
      <pre><code>import { db, products, salesOrders, salesOrderLines } from 'inflow-get'
import { eq, sql, desc } from 'drizzle-orm'

// Top selling products this month
const topProducts = db
  .select({
    name: products.name,
    totalSold: sql`sum(${salesOrderLines.quantity})`,
  })
  .from(salesOrderLines)
  .innerJoin(products, eq(salesOrderLines.productId, products.productId))
  .groupBy(products.productId)
  .orderBy(desc(sql`sum(${salesOrderLines.quantity})`))
  .limit(10)
  .all()</code></pre>
    </div>

    <div class="use-case">
      <h4><span class="badge put">PUT</span> Bulk Price Update</h4>
      <p>Update prices for a category of products.</p>
      <pre><code>import { db, products } from 'inflow-get'
import { createClient, putProduct } from 'inflow-put'
import { eq } from 'drizzle-orm'

const client = createClient({ apiKey, companyId })

// Get all products in a category
const categoryProducts = db
  .select()
  .from(products)
  .where(eq(products.categoryId, 'widgets-category-id'))
  .all()

// Update each with 10% price increase
for (const product of categoryProducts) {
  await putProduct(client, {
    productId: product.productId,
    // ... price update logic
  })
}</code></pre>
    </div>

    <div class="use-case">
      <h4><span class="badge both">GET+PUT</span> Inventory Sync Tool</h4>
      <p>Read from external system, write to Inflow.</p>
      <pre><code>import { db, products } from 'inflow-get'
import { createClient, putStockAdjustment } from 'inflow-put'

const client = createClient({ apiKey, companyId })

// External system says we have 50 units of SKU-123
const externalCount = await externalSystem.getCount('SKU-123')

// Check local SQLite
const product = db
  .select()
  .from(products)
  .where(eq(products.sku, 'SKU-123'))
  .get()

// Create adjustment if different
if (product && externalCount !== product.quantityOnHand) {
  await putStockAdjustment(client, {
    stockAdjustmentId: randomUUID(),
    // ... adjustment details
  })
}</code></pre>
    </div>

    <div class="use-case">
      <h4><span class="badge both">GET+PUT</span> Order Import from CSV</h4>
      <p>Read product IDs from local DB, create orders via API.</p>
      <pre><code>import { db, products, customers } from 'inflow-get'
import { createClient, putSalesOrder } from 'inflow-put'
import { eq } from 'drizzle-orm'

const client = createClient({ apiKey, companyId })

for (const row of csvRows) {
  // Lookup IDs locally (instant)
  const product = db.select().from(products)
    .where(eq(products.sku, row.sku)).get()
  const customer = db.select().from(customers)
    .where(eq(customers.name, row.customerName)).get()

  // Create order via API
  await putSalesOrder(client, {
    salesOrderId: randomUUID(),
    customerId: customer.customerId,
    lines: [{
      salesOrderLineId: randomUUID(),
      productId: product.productId,
      quantity: row.qty,
    }]
  })
}</code></pre>
    </div>

    <h2>Data Flow Patterns</h2>

    <div class="mermaid">
flowchart TB
    subgraph read["Read Path (Fast, Local)"]
        R1["Query SQLite"]
        R2["Join Tables"]
        R3["Aggregate"]
        R4["Return to App"]
        R1 --> R2 --> R3 --> R4
    end

    subgraph write["Write Path (Validated, Remote)"]
        W1["Build Payload"]
        W2["Validate with Zod"]
        W3["Strip readOnly Fields"]
        W4["PUT to API"]
        W1 --> W2 --> W3 --> W4
    end

    APP["Your App"]
    DB[(SQLite)]
    API[("Inflow API")]

    APP -->|"read"| read
    read --> DB

    APP -->|"write"| write
    write --> API

    style read fill:#0f3460,stroke:#00d9ff
    style write fill:#0f3460,stroke:#e94560
    </div>

    <h2>Why This Architecture?</h2>

    <table>
      <tr>
        <th>Problem</th>
        <th>Solution</th>
      </tr>
      <tr>
        <td>API rate limits (60 req/min)</td>
        <td><span class="highlight2">inflow-get</span> seeds once, query SQLite unlimited</td>
      </tr>
      <tr>
        <td>Slow API for complex queries</td>
        <td><span class="highlight2">inflow-get</span> enables SQL joins, aggregations locally</td>
      </tr>
      <tr>
        <td>No offline access</td>
        <td><span class="highlight2">inflow-get</span> SQLite works without network</td>
      </tr>
      <tr>
        <td>Complex PUT payloads</td>
        <td><span class="highlight">inflow-put</span> validates, strips invalid fields</td>
      </tr>
      <tr>
        <td>Undocumented constraints</td>
        <td><span class="highlight">inflow-put</span> knows readOnly, immutable, required</td>
      </tr>
      <tr>
        <td>Will my PUT work?</td>
        <td><span class="highlight">inflow-put</span> integration tests prove it</td>
      </tr>
    </table>

    <h2>Project Structure</h2>

    <pre><code>my-inflow-app/
├── package.json
├── .env                    # INFLOW_API_KEY, INFLOW_COMPANY_ID
├── data/
│   └── inflow.db           # SQLite (gitignored, created by seed)
├── src/
│   ├── index.ts            # Entry point
│   ├── queries/            # Drizzle queries using inflow-get
│   │   ├── products.ts
│   │   ├── orders.ts
│   │   └── reports.ts
│   ├── writes/             # Functions using inflow-put
│   │   ├── sync-prices.ts
│   │   ├── create-order.ts
│   │   └── adjust-stock.ts
│   └── services/           # Business logic
│       └── ...
└── scripts/
    └── seed.ts             # Runs inflow-get seeder</code></pre>

    <h2>Environment Setup</h2>

    <pre><code># .env
INFLOW_API_KEY=your-api-key-here
INFLOW_COMPANY_ID=your-company-guid-here</code></pre>

    <pre><code># First time setup
npm install
npx tsx scripts/seed.ts    # Populates data/inflow.db

# Run your app
npm start</code></pre>

    <h2>The Mental Model</h2>

    <div class="mermaid">
flowchart LR
    subgraph yours["What You Build"]
        APP["Your App"]
    end

    subgraph pair["The Library Pair"]
        direction TB
        GET["inflow-get<br/>━━━━━━━━━<br/>Read Side"]
        PUT["inflow-put<br/>━━━━━━━━━<br/>Write Side"]
    end

    subgraph inflow["Inflow's World"]
        API[("Cloud API")]
    end

    APP <--> pair
    pair <--> API

    style yours fill:#16213e,stroke:#e94560,stroke-width:2px
    style pair fill:#0f3460,stroke:#00d9ff,stroke-width:2px
    style inflow fill:#1a1a2e,stroke:#e94560
    style GET fill:#0f3460,stroke:#00d9ff
    style PUT fill:#0f3460,stroke:#e94560
    </div>

    <div class="card">
      <p style="font-size: 1.1rem; text-align: center; margin: 0;">
        <span class="highlight2">inflow-get</span> brings the data to you.<br/>
        <span class="highlight">inflow-put</span> sends your changes back.<br/>
        <strong>You focus on your app.</strong>
      </p>
    </div>

  </div>

  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: 'dark',
      themeVariables: {
        primaryColor: '#0f3460',
        primaryTextColor: '#eaeaea',
        primaryBorderColor: '#e94560',
        lineColor: '#e94560',
        secondaryColor: '#16213e',
        tertiaryColor: '#1a1a2e',
        background: '#1a1a2e',
        mainBkg: '#16213e',
        nodeBorder: '#e94560',
        clusterBkg: '#16213e',
        clusterBorder: '#e94560',
        titleColor: '#e94560',
        edgeLabelBackground: '#16213e',
        noteBkgColor: '#0f3460',
        noteTextColor: '#eaeaea',
        noteBorderColor: '#00d9ff',
      }
    });
  </script>
</body>
</html>
